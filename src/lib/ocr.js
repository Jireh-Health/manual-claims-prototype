/**
 * Tesseract.js OCR wrapper
 * Supports: image files (JPG/PNG) and canvas elements (from pdf.js)
 */
import { createWorker } from 'tesseract.js'

let worker = null

async function getWorker() {
  if (!worker) {
    worker = await createWorker('eng', 1, {
      logger: () => {}, // suppress logs
    })
  }
  return worker
}

/**
 * OCR an image File object
 * @param {File} file
 * @param {(progress: number) => void} onProgress
 * @returns {Promise<string>} raw OCR text
 */
export async function ocrImageFile(file, onProgress) {
  const w = await getWorker()
  const url = URL.createObjectURL(file)
  try {
    const result = await w.recognize(url, {}, {})
    onProgress?.(100)
    return result.data.text
  } finally {
    URL.revokeObjectURL(url)
  }
}

/**
 * OCR a canvas element (from pdf.js page render)
 * @param {HTMLCanvasElement} canvas
 * @param {(progress: number) => void} onProgress
 * @returns {Promise<string>} raw OCR text
 */
export async function ocrCanvas(canvas, onProgress) {
  const w = await getWorker()
  const result = await w.recognize(canvas, {}, {})
  onProgress?.(100)
  return result.data.text
}

/**
 * Extract structured invoice data from raw OCR text.
 * Optimised for the Jumuia Hospitals PDF layout generated by generate-samples.mjs:
 *   Invoice Number : INV-2026-013
 *   Date           : 2026-01-15
 *   1. Description                        KES 1,200
 *   TOTAL AMOUNT                          KES 2,000
 *
 * Also handles generic invoice formats as fallback.
 */
export function extractInvoiceData(text) {
  const lines = text.split('\n').map((l) => l.trim()).filter(Boolean)

  // ── Invoice number ─────────────────────────────────────────────────────────
  // Priority 1: "Invoice Number : INV-2026-013" label pattern
  let invoiceNumber = ''
  const invLabelMatch = text.match(
    /invoice\s+number\s*:\s*([A-Z]{2,6}[-–][0-9]{2,6}[-–][0-9]{2,6})/i
  )
  if (invLabelMatch) {
    invoiceNumber = invLabelMatch[1].toUpperCase()
  } else {
    // Fallback: standalone INV-YYYY-NNN pattern anywhere in text
    const invStandalone = text.match(/\b(INV[-–][0-9]{4}[-–][0-9]{2,6})\b/i)
    if (invStandalone) invoiceNumber = invStandalone[1].toUpperCase()
  }

  // ── Date ───────────────────────────────────────────────────────────────────
  // Priority 1: "Date : YYYY-MM-DD" label pattern (may have extra spaces between "Date" and ":")
  let date = ''
  const dateLabelMatch = text.match(
    /\bdate\s*:\s*(\d{4}[-\/]\d{1,2}[-\/]\d{1,2})/i
  )
  if (dateLabelMatch) {
    date = dateLabelMatch[1]
  } else {
    // Fallback: any date-like pattern
    const dateGeneric = text.match(
      /(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4}|\d{4}[\/\-\.]\d{1,2}[\/\-\.]\d{1,2})/
    )
    if (dateGeneric) date = dateGeneric[1]
  }

  // ── Line items ─────────────────────────────────────────────────────────────
  // Pattern: "1. Description                        KES 1,200"
  // OCR may compress whitespace, so match "N. text ... KES amount" loosely
  const items = []
  for (const line of lines) {
    // Numbered item: "1. Description   KES 1,200" or "1. Description   1,200"
    const numItemMatch = line.match(
      /^\d+\.\s+(.+?)\s+(?:KES\s*)?([\d,]+(?:\.\d{1,2})?)$/i
    )
    if (numItemMatch) {
      const desc = numItemMatch[1].trim()
      const amt  = parseFloat(numItemMatch[2].replace(/,/g, ''))
      if (amt > 0 && !/total|subtotal|tax|vat/i.test(desc)) {
        items.push({ id: crypto.randomUUID(), description: desc, amount: amt })
      }
      continue
    }
    // Generic two-column line: "Description   1,200" (2+ spaces between text and number)
    const genericMatch = line.match(/^(.{5,50}?)\s{2,}([\d,]+(?:\.\d{1,2})?)$/)
    if (genericMatch) {
      const desc = genericMatch[1].trim()
      const amt  = parseFloat(genericMatch[2].replace(/,/g, ''))
      if (amt > 0 && !/total|subtotal|tax|vat|amount|invoice|date|page|kes|ksh|facility|payment/i.test(desc)) {
        items.push({ id: crypto.randomUUID(), description: desc, amount: amt })
      }
    }
  }

  // ── Total amount ───────────────────────────────────────────────────────────
  // Priority 1: "TOTAL AMOUNT   KES 2,000" — the label appears on the same line
  let amount = 0
  const totalLabelMatch = text.match(
    /total\s+amount\s+(?:KES\s*)?([\d,]+(?:\.\d{1,2})?)/i
  )
  if (totalLabelMatch) {
    amount = parseFloat(totalLabelMatch[1].replace(/,/g, ''))
  } else {
    // Fallback: last "KES X,XXX" occurrence in the document (usually the total)
    const allKes = [...text.matchAll(/KES\s*([\d,]+(?:\.\d{1,2})?)/gi)]
    if (allKes.length > 0) {
      amount = parseFloat(allKes[allKes.length - 1][1].replace(/,/g, ''))
    }
  }

  // Last resort: sum of extracted line items
  if (!amount) amount = items.reduce((s, i) => s + i.amount, 0)

  return {
    invoiceNumber,
    amount,
    date,
    items,
    rawText: text,
  }
}

/**
 * Intentional OCR error scenario for demo ("Load Demo Data")
 */
export function getDemoOcrData() {
  return {
    // INV-2026-013 — Radiology: Chest X-Ray 1500 + Abdominal ultrasound 3500 = 5000
    // OCR errors: amount misread as 500, "Chest X-Ray" misread as "Chest X-Rav"
    invoiceNumber: 'INV-2026-013',
    amount: 500, // OCR misread 5000 as 500
    date: '2026-01-15',
    items: [
      { id: crypto.randomUUID(), description: 'Chest X-Rav', amount: 150 }, // OCR error
      { id: crypto.randomUUID(), description: 'Abdominal ultrasound', amount: 350 },
    ],
    rawText: 'Demo OCR text — contains intentional errors for correction demo.',
    isDemo: true,
  }
}
